{
  "name": "Jsonapi compliable",
  "tagline": "",
  "body": "# Overview\r\n\r\nThis library provides a simple DSL for [jsonapi.org-compliant](http://jsonapi.org) requests. Among other things, this will help you:\r\n\r\n* Paginate\r\n* Sort\r\n* Filter\r\n* Whitelist inclusion of related resources\r\n* Calculate stats (totals, averages, etc)\r\n* Deal with customizable fieldsets\r\n* Guard certain behavior (based on the current user's role, for instance)\r\n* Deserialize incoming payloads (including nested payloads)\r\n\r\nIn other words, we provide much of the same behavior as the wonderful [jsonapi-resources](https://github.com/cerebris/jsonapi-resources) gem, but with a more 'traditional Rails' approach built on top of the widely-used [active_model_serializers](https://github.com/rails-api/active_model_serializers).\r\n\r\nAll with as little code as possible. Everything is customizable and no ActiveRecord is required (though it's a nice default).\r\n\r\n### Installation\r\n\r\nAdd to your `Gemfile`:\r\n\r\n`gem jsonapi_compliable`\r\n\r\nAnd include the mixin in your controller:\r\n\r\n```ruby\r\nclass ApplicationController < ActionController::Base\r\n  include JsonapiCompliable\r\nend\r\n```\r\n\r\n### Quickstart - Pagination/Sorting/Sparse Fieldsets\r\n\r\n```ruby\r\nclass PeopleController < ApplicationController\r\n  jsonapi { }\r\n\r\n  def index\r\n    people = People.all\r\n    render_ams(people)\r\n  end\r\nend\r\n```\r\n\r\nThis API will now support the JSONAPI pagination and sorting parameters, in addition to sparse fieldsets. In other words, the following URLs work:\r\n\r\n```\r\n/people?page[number]=1&page[size]=20\r\n/people?sort=name\r\n/people?sort=-name\r\n/people?fields[people]=name,updated_at\r\n```\r\n\r\n### Filtering\r\n\r\nAdd `allow_filter`:\r\n\r\n```ruby\r\nclass PeopleController < ApplicationController\r\n  jsonapi do\r\n    allow_filter :name\r\n  end\r\n\r\n  # ... code ...\r\nend\r\n```\r\n\r\nWe now support `/people?filter[name]=Jane`. If a query comes in for a filter not allowed, `JsonapiCompliable::Errors::BadFilter` will be raised.\r\n\r\nThe default behavior is to assume ActiveRecord's `.where(name: 'Jane')`. To customize:\r\n\r\n```ruby\r\nallow_filter :name_prefix do |scope, value|\r\n  scope.where([\"name LIKE ?\", \"#{value}%\"])\r\nend\r\n```\r\n\r\nFilters can be guarded:\r\n\r\n```ruby\r\nclass PeopleController < ApplicationController\r\n  jsonapi do\r\n    allow_filter :name, if: :admin?\r\n  end\r\n\r\n  def admin?\r\n    current_user.role == :admin\r\n  end\r\nend\r\n```\r\n\r\nThe above will raise `JsonapiCompliable::Errors::BadFilter` if the user is not an admin.\r\n\r\nYou can also use `default_filter`:\r\n\r\n```ruby\r\njsonapi do\r\n  default_filter :private do |scope|\r\n    scope.where(private: false)\r\n  end\r\nend\r\n```\r\n\r\nThis filter can be overridden if there is a corresponding `allow_filter` and `filter[private]` is a query parameter.\r\n\r\nFilters can be aliased. Want the URL `/people?filter[name]` to query `full_name`? Try this:\r\n\r\n```ruby\r\nallow_filter :full_name, aliases: [:name]\r\n```\r\n\r\n### Includes (\"Sideloading\")\r\n\r\n```ruby\r\njsonapi do\r\n  includes whitelist: { index: [:siblings, {company: :address}] }\r\nend\r\n```\r\n\r\nWe'd now support the URL `?include=siblings,company.address`. Any `include` not whitelisted will be silently dropped. If you're using ActiveRecord, everything will be automatically eager loaded.\r\n\r\n### Extra Fields\r\n\r\nThis is not part of the base jsonapi spec, but it is compatible. Imagine you have a computationally-expensive field you only want rendered when explicitly requested by the user.\r\n\r\nStart by including [jsonapi_ams_extensions](https://bbgithub.dev.bloomberg.com/InfrastructureExperience/jsonapi_ams_extensions) in your serializer and define the extra attribute:\r\n\r\n```ruby\r\nclass PersonSerializer < ActiveModel::Serializer\r\n  # You probably want this in an ApplicationSerializer\r\n  include JsonapiAmsExtensions \r\n\r\n  # extra_attribute knows to only include this when requested\r\n  extra_attribute :net_worth\r\nend\r\n```\r\n\r\nThen add to your controller `jsonapi` definition:\r\n\r\n```ruby\r\njsonapi do\r\n  extra_field(people: [:net_worth_in_bitcoins])\r\nend\r\n```\r\n\r\nThis field will now only be rendered when requested with `/people?extra_fields=net_worth_in_bitcoins`.\r\n\r\nYou can place a guard within your serializer, if needed:\r\n\r\n```ruby\r\nclass PersonSerializer < ApplicationSerializer\r\n  extra_attribute :net_worth\r\n\r\n  # This method is generated for any extra_attribute\r\n  def allow_net_worth?\r\n    return false unless current_user.admin?\r\n    super\r\n  end\r\nend\r\n```\r\n\r\nFinally, you may need to eager load some data in order to generate this attribute. To do this, pass a block to `extra_field` in your controller's `jsonapi` definition:\r\n\r\n```ruby\r\nextra_field(people: [:net_worth_in_bitcoins]) do |scope|\r\n  scope.includes(:assets)\r\nend\r\n```\r\n\r\n### Stats\r\n\r\nAdd `allow_stat`:\r\n\r\n```ruby\r\nclass PeopleController < ApplicationController\r\n  jsonapi do\r\n    allow_stat total: [:count]\r\n  end\r\n\r\n  # ... code ...\r\nend\r\n```\r\n\r\nWe now support `/people?stats[total]=count`. The `meta` section of the response would look like:\r\n\r\n```ruby\r\n{\r\n  meta: {\r\n    stats: {\r\n      total: {\r\n        count: 100\r\n      }\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nStats run against the normal scope, sans pagination. So if we added `&filter[name_prefix]=a`, we would get the total count of all people with name starting with 'a'.\r\n\r\nThe above uses a default calculation function, `count`, which will work out-of-the-box with `ActiveRecord`. Other default calculations are also supported:\r\n\r\n```ruby\r\nallow_stat cost: [:sum, :average, :maximum, :minimum]\r\n```\r\n\r\nEach calculation can be customized (for instance, if you are not using ActiveRecord):\r\n\r\n```ruby\r\nallow_stat :cost do\r\n  # default behavior, equivalent to allow_stat cost: [:count]\r\n  sum { |scope, attr| scope.count }\r\n\r\n  # or if 'scope' is an array in this case\r\n  sum { |scope, attr| scope.sum { |item| item.cost } }\r\nend\r\n```\r\n\r\nFinally, arbitrary statistics can also be added:\r\n\r\n```ruby\r\nallow_stat :cost do\r\n  standard_deviation { |scope, attr| ... }\r\nend\r\n```\r\n\r\n### Deserialization\r\n\r\nJSON API payloads for POST/PUT/PATCH can be a pain to deal with in Rails. Call `deserialize_jsonapi!` to get a Rails-friendly payload:\r\n\r\n```ruby\r\nclass PostsController < ApplicationController\r\n  before_action :deserialize_jsonapi!, only: [:update, :create]\r\nend\r\n```\r\n\r\nWould take this:\r\n\r\n```ruby\r\n  {\r\n    data: {\r\n      type: 'posts',\r\n      attributes: {\r\n        title: 'my post',\r\n      },\r\n      relationships: {\r\n        comments: {\r\n          data: [\r\n            { type: 'comments', attributes: { body: 'my comment' } }\r\n          ]\r\n        }\r\n      }\r\n    }\r\n  }\r\n```\r\n\r\nAnd deserialize it to:\r\n\r\n```ruby\r\n  {\r\n    post: {\r\n      title: 'my post',\r\n      comments_attributes: [{\r\n        body: 'my comment'\r\n      }]\r\n    }\r\n  }\r\n```\r\n\r\nThis differs from other deserializers in that nested relationships are converted into an `accepts_nested_attributes_for`-friendly payload.\r\n\r\nYou can still reference the original parameters with `raw_params`.\r\n\r\n### Customizing\r\n\r\nAll of the macros in the `jsonapi` DSL can be customized with a block. Not using ActiveRecord? No problem - you can use your ORM's scoping mechanism, or simply use the DSL to build up a hash that can be passed to an ORM of your choice:\r\n\r\n```ruby\r\njsonapi do\r\n  allow_filter :name do |scope, value|\r\n    scope[:conditions] ||= {}\r\n    scope[:conditions].merge!(name: value)\r\n  end\r\n\r\n  sort do |scope, att, dir|\r\n    scope.merge!(order: { att => dir })\r\n  end\r\n\r\n  paginate do |scope, current_page, per_page|\r\n    offset = (current_page - 1 ) * per_page\r\n    scope.merge!(limit: per_page, offset: offset)\r\n  end\r\n\r\n  includes whitelist: :department do |scope, includes|\r\n    scope.merge!(include: includes)\r\n  end\r\nend\r\n\r\ndef index\r\n  hash = jsonapi_scope({})\r\n  puts hash\r\n  # {\r\n  #   order: { id: :asc },\r\n  #   limit: 20,\r\n  #   offset: 0,\r\n  #   conditions: { name: 'foo' },\r\n  #   include: :department\r\n  # }\r\nend\r\n```\r\n\r\nAnd hereâ€™s an example using the elasticsearch gem [trample](http://richmolj.github.io/trample):\r\n\r\n```ruby\r\nclass EmployeesController < ApplicationController\r\n  jsonapi do\r\n    allow_filter :name do |scope, value|\r\n      scope.condition(:name).eq(value)\r\n    end\r\n\r\n    allow_filter :name_prefix do |scope, value|\r\n      scope.condition(:name).starts_with(value)\r\n    end\r\n\r\n    paginate do |scope, current_page, per_page|\r\n      scope.metadata.pagination.current_page = current_page\r\n      scope.metadata.pagination.per_page = per_page\r\n      scope\r\n    end\r\n\r\n    sort do |scope, att, dir|\r\n      scope.metadata.sort = [{att: att, dir: dir}]\r\n      scope\r\n    end\r\n\r\n    includes whitelist: { index: :pets } do |scope, includes|\r\n      scope.metadata.records[:includes] = includes\r\n      scope\r\n    end\r\n  end\r\n\r\n  def index\r\n    search = jsonapi_scope(Search::Employee.new)\r\n    search.query!\r\n\r\n    render_ams(search.records.to_a)\r\n  end\r\nend\r\n```\r\n\r\n### render_ams and jsonapi_scope\r\n\r\nBy default, `render_ams` will automatically scope the object you pass to it. Call `render_ams(object, scope: false)` to opt-out of this behavior.\r\n\r\nIn addition, you may want to explicitly scope before `render_ams` to provide additional customization. The following is a typical `show` action:\r\n\r\n```ruby\r\ndef show\r\n  person = jsonapi_scope(Person.all).find(params[:id])\r\n  render_ams(person)\r\nend\r\n```\r\n\r\nWith this explicit scope, all the normal scoping rules are applied (as we need `include`, `fields`, etc), then chained with `find`. We can then pass the record directly to `render_ams` - it won't be scoped again.",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}